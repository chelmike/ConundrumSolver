Перед Вами небольшой проект, который решает задачу [головоломки](readme.md).

#### Основные положения
- Игровое поле представляет собой ряд фиксированных мест. Присвоим местам индексы от #0 до #7.   
- Цифры, расставленные на поле, будут обозначать сами себя, а пустое поле обозначим цифрой *0*. 
- Будем рассматривать набор цифр, расставленных определённым образом на игровом поле, как *состояние*.
Тогда любое состояние сможем записать последовательностью цифр, расставленных на клетках поля. Например,
исходное состояние (на [рисунке](playingField.png) в [описании головоломки](conundrumDesc.md)) можем записать так:
**1 2 3 4 0 5 6 7**. Это же состояние и будет, в соответствии с задачей головоломки, условием завершения работы
для нашего алгоритма поиска решения.
- Одно состояние переходит в другое путём *"перемещения"* пустой клетки.
- Зададим набор возможных (допустимых) переходов между состояниями игрового поля как 2-мерный массив - [8][***].
Каждому *i*-му индексу поля соответствует массив индексов, в которые можно передвинуть пустую клетку. Например,
индексу *#3* соответствует массив *[1, 4, 6]* - т.е. пустое место из клетки поля #3 можно переместить в поля
*#1*, *#4* или *#6*.
- Путь решения, который требуется найти, - это последовательность переходов, т.е. перемещений пустой клетки на
новое место. При этом каждый переход записывается номером (индексом) поля, в которое перемещается пустая клетка.

#### Идея решения
По условиям задачи нам даны два состояния - начальное и конечное. Будем вести учёт состояний, отличных от конечного,
в которых игровое поле уже было (перечень посещённых состояний).

Запускаем бесконечный цикл, условием выхода из
которого будет конечное состояния. На первом шаге у нас один путь, и он пустой.
Все возможные дальнейшие переходы из текущего состояния - это возможные пути, которые прибавляют к текущему пути
(например, мы попали в текущее состояниеA = [..1 3]), приведшему к данному состоянию, один из возможных переходов дальше.
Таким образом, из текущего состояния у нас есть несколько путей (например, B = [..1 3 1], C = [..1 3 4] и D = [..1 3 6]).
Если в текущем состоянии мы ещё не были, добавляем его в перечень посещённых состояний и переходим в него - т.е. добавляем
новый путь в наш набор. Иначе, если в этом состоянии мы уже были, не добавляем путь: этот путь нас больше
не интересует, т.к. мы уже были в этом состоянии. Заменяем в нашем наборе путей исходный путь на набор новых путей
(от одного до двух новых путей).

Соблюдение перечисленных правил и условий даёт гарантию, что первый найденный путь из исходного состояния в конечное
будет также и самым коротким. Возможно, одним из путей самой короткой длины, если их несколько, но точно не длиннее.
